== Basic notes on Exploit Development ==

x86/x86-64 stack frame (may vary from compiler to compiler)

	{{ Lower addresses }}
	/-------------------------------------------------
	| ESP/RSP
	|  		function's stack frame
	|
	| EBP/RBP 		-- Saved EBP from the caller
	|-------------------------------------------------
	| Return address
	|-------------------------------------------------
	|
	| Caller's stack space
	|
	\-------------------------------------------------
	{{ Higher addresses }}

Unlike gcc/clang, MSVC's stack frame is somewhat different. It _only_ saves the return
address and not the previous stack frame ptr.
Thus, msvc does the following on entry:

	sub ebp/rbp, <amount>

and on exit:

	add ebp/rbp, <amount>

(the last - before each ret instruction, if there is more than one).
This way MSVC uses (a bit) less stack memory per call, but has to unwind stack
manually before return.



== Buf overflow testing ==

In order to identiy the buffer location that overrides the return address,
use some pattern like:

buf = "A1A2A3A4A5...B1B2B3...Z9"

Then, "decoding" the address from the exception message will allow to identify particular
part of the string that is being used as the return address.


On windows, try using Imunity Debugger - a special debugger to debug/develop new exploits.
Use "mona" extension for better results.

!mona pattern_create 1000

	-- Generate pattern like above example

!mona patter_offset 32714131

	-- Searches for a particular location / offset

!mona findmsp

!mona jmp -r esp

	- find any instruction in the all loaded modules of the process that does an equivalent
	of 'jmp [esp]' (not even necessary the same command)


== Metasploit metasm_shell.rb: ==

	run the ruby script directly:

		/usr/share/metasploit-framework/tools/exploit/metasm_shell.rb

	gives you the prompt:

		metasm > sub esp, 1500
		"\x81\xec\xdc\x05\x00\x00"
		metasm >


== Shellcode with msfvenom ==

	msfvenom -p windows/shell_bind_tcp -s 607 -b '\x00\x40\x0d\x0a' -f python

	-p - payload
	-s - exploit/shellcode size
	-b - forbidden bytes (bytes to avoid in the output buffer)
	-f - output format

NOTE: if using the trick with 'jmp [esp]', then append 'add esp, -1500' to the shellcode
(to the correct amount)

NOTE: for SEH exploits, it is often useful to use/find pop-pop-ret byte sequence in the
process' address space.


== x86 short jump: ==
	\xEB\x58 -- jump by 0x58 bytes



=== PWN TOOLS ===

	A super useful python module for exploit development.

	pip install pwntools

> from pwn import *

> p(0)
b'\x00'

> p64(0x..., endian='big')
hex(u64('\xef\xad...'))

> asm('nop')
b'\x90'

> disasm(b'\x8b\x45\xfc')

	0: 8b 45 FC		move eax, DW PTR[EBP-0x4]

> ELF('/lib/.../libc.so.6')
...

----
context.update(arch='amd64', os='linux')

More use ideas on page 65 of 'Gray Hat Hacking' book.


